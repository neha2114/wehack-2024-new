"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  initializeAuthProxy: () => initializeAuthProxy
});
module.exports = __toCommonJS(src_exports);
var import_http = __toESM(require("http"));
var import_http_proxy = __toESM(require("http-proxy"));
var import_cookie = __toESM(require("cookie"));
var import_backend_js_utilities = require("@propelauth/backend-js-utilities");
function initializeAuthProxy(_0) {
  return __async(this, arguments, function* ({
    authUrl,
    integrationApiKey,
    urlWhereYourProxyIsRunning,
    proxyPort,
    target
  }) {
    const urlWhereYourProxyIsRunningOrigin = new URL(urlWhereYourProxyIsRunning).origin;
    const auth = yield (0, import_backend_js_utilities.initAuthByFetchingConfig)({
      authUrl,
      integrationApiKey,
      redirectUri: `${urlWhereYourProxyIsRunningOrigin}/api/auth/callback`
    });
    const proxy = new import_http_proxy.default.createProxyServer({
      target,
      changeOrigin: true,
      secure: target.protocol === "https:"
    });
    proxy.on("proxyRes", function(proxyRes, req) {
      const existingCookies = proxyRes.headers["set-cookie"] || [];
      if (req._access_token) {
        const { accessTokenCookieValue, shortAccessTokenCookieValue } = getAccessTokenCookieValues(
          req._access_token
        );
        existingCookies.push(accessTokenCookieValue);
        existingCookies.push(shortAccessTokenCookieValue);
      }
      if (req._refresh_token) {
        const refreshTokenCookieValue = getRefreshTokenCookieValue(req._refresh_token);
        existingCookies.push(refreshTokenCookieValue);
      }
      proxyRes.headers["set-cookie"] = existingCookies;
    });
    const proxyServer = import_http.default.createServer(function(basicReq, res) {
      const req = basicReq;
      parseUrlAndAddToReq(req);
      const cookies = import_cookie.default.parse(req.headers.cookie || "");
      const accessToken = cookies[ACCESS_TOKEN_COOKIE_NAME];
      const shortAccessToken = cookies[SHORT_ACCESS_TOKEN_COOKIE_NAME];
      const refreshToken = cookies[REFRESH_TOKEN_COOKIE_NAME];
      if (req.method === "GET") {
        if (req._pathname === "/api/auth/login" || req._pathname === "/api/auth/signup") {
          const isSignup = req._pathname === "/api/auth/signup";
          return redirectToSignupOrLogin(auth, isSignup, res);
        } else if (req._pathname === "/api/auth/callback") {
          return callbackHandler(auth, req, res);
        } else if (req._pathname === "/api/auth/logout") {
          return logoutGetHandler(auth, req, res);
        }
      } else if (req.method === "POST") {
        if (req._pathname === "/api/auth/logout") {
          return logoutPostHandler(auth, req, res);
        }
      }
      if (shortAccessToken) {
        proxy.web(req, res);
        return;
      }
      if (refreshToken) {
        auth.token.refreshTokens(refreshToken).then((response) => {
          if (response.error === "none") {
            req._access_token = response.accessToken;
            req._refresh_token = response.refreshToken;
            proxy.web(req, res);
          } else if (response.error === "unauthorized") {
            redirectToSignupOrLogin(auth, false, res);
          } else {
            if (accessToken) {
              proxy.web(req, res);
            } else {
              res.writeHead(500);
              res.end();
            }
          }
        });
      } else {
        redirectToSignupOrLogin(auth, false, res);
      }
    });
    proxyServer.on("upgrade", function(req, socket, head) {
      proxy.ws(req, socket, head);
    });
    proxyServer.on("error", function(err, req, res) {
      res.writeHead(500, {
        "Content-Type": "text/plain"
      });
      res.end("An unexpected error occurred");
    });
    return proxyServer.listen(proxyPort);
  });
}
var ACCESS_TOKEN_COOKIE_NAME = "__pa_at";
var SHORT_ACCESS_TOKEN_COOKIE_NAME = "__pa_ats";
var REFRESH_TOKEN_COOKIE_NAME = "__pa_rt";
var STATE_COOKIE_NAME = "__pa_state";
var DEFAULT_COOKIE_OPTIONS = {
  httpOnly: true,
  secure: true,
  path: "/",
  sameSite: "lax"
};
function getAccessTokenCookieValues(accessToken) {
  if (accessToken) {
    const accessTokenCookieValue = import_cookie.default.serialize(ACCESS_TOKEN_COOKIE_NAME, accessToken, __spreadProps(__spreadValues({}, DEFAULT_COOKIE_OPTIONS), {
      maxAge: 60 * 29
    }));
    const shortAccessTokenCookieValue = import_cookie.default.serialize(SHORT_ACCESS_TOKEN_COOKIE_NAME, accessToken, __spreadProps(__spreadValues({}, DEFAULT_COOKIE_OPTIONS), {
      maxAge: 60 * 10
    }));
    return { accessTokenCookieValue, shortAccessTokenCookieValue };
  } else {
    const accessTokenCookieValue = import_cookie.default.serialize(ACCESS_TOKEN_COOKIE_NAME, "", __spreadProps(__spreadValues({}, DEFAULT_COOKIE_OPTIONS), {
      maxAge: 0
    }));
    const shortAccessTokenCookieValue = import_cookie.default.serialize(SHORT_ACCESS_TOKEN_COOKIE_NAME, "", __spreadProps(__spreadValues({}, DEFAULT_COOKIE_OPTIONS), {
      maxAge: 0
    }));
    return { accessTokenCookieValue, shortAccessTokenCookieValue };
  }
}
function getRefreshTokenCookieValue(refreshToken) {
  if (refreshToken) {
    return import_cookie.default.serialize(REFRESH_TOKEN_COOKIE_NAME, refreshToken, DEFAULT_COOKIE_OPTIONS);
  } else {
    return import_cookie.default.serialize(REFRESH_TOKEN_COOKIE_NAME, "", __spreadProps(__spreadValues({}, DEFAULT_COOKIE_OPTIONS), {
      maxAge: 0
    }));
  }
}
function setCookiesAndRedirectToHome(res, accessToken, refreshToken) {
  const { accessTokenCookieValue, shortAccessTokenCookieValue } = getAccessTokenCookieValues(accessToken);
  const refreshTokenCookieValue = getRefreshTokenCookieValue(refreshToken);
  res.writeHead(302, {
    Location: "/",
    "Set-Cookie": [accessTokenCookieValue, shortAccessTokenCookieValue, refreshTokenCookieValue]
  });
  res.end();
}
function redirectToSignupOrLogin(auth, isSignup, res) {
  const { authorizeUrl, state } = auth.user.redirectToSignupOrLogin(isSignup);
  res.writeHead(302, {
    Location: authorizeUrl,
    "Set-Cookie": import_cookie.default.serialize(STATE_COOKIE_NAME, state, DEFAULT_COOKIE_OPTIONS)
  });
  res.end();
}
function callbackHandler(auth, req, res) {
  return __async(this, null, function* () {
    const stateFromCookie = import_cookie.default.parse(req.headers.cookie || "")[STATE_COOKIE_NAME];
    const stateFromQueryParams = req._queryParams.get("state") || void 0;
    const codeFromQueryParams = req._queryParams.get("code") || void 0;
    const response = yield auth.user.finishLogin({
      stateFromCookie,
      stateFromQueryParams,
      codeFromQueryParams
    });
    if (response.error) {
      if (response.error_type === "state_mismatch") {
        return redirectToSignupOrLogin(auth, false, res);
      }
      if (response.error_type === "bad_config") {
        console.log(
          "Couldn't finish the login process for this user. This is most likely caused by an incorrect PROPELAUTH_API_KEY."
        );
      }
      res.writeHead(500);
      res.write("Unexpected error");
      res.end();
      return;
    }
    return setCookiesAndRedirectToHome(res, response.accessToken, response.refreshToken);
  });
}
function logoutGetHandler(auth, req, res) {
  return __async(this, null, function* () {
    const cookies = import_cookie.default.parse(req.headers.cookie || "");
    const refreshToken = cookies[REFRESH_TOKEN_COOKIE_NAME];
    if (!refreshToken) {
      return setCookiesAndRedirectToHome(res, void 0, void 0);
    }
    const response = yield auth.token.refreshTokens(refreshToken);
    if (response.error === "none") {
      return setCookiesAndRedirectToHome(res, response.accessToken, response.refreshToken);
    } else if (response.error === "unauthorized") {
      return setCookiesAndRedirectToHome(res, void 0, void 0);
    } else {
      res.writeHead(500);
      res.end();
    }
  });
}
function logoutPostHandler(auth, req, res) {
  return __async(this, null, function* () {
    const cookies = import_cookie.default.parse(req.headers.cookie || "");
    const refreshToken = cookies[REFRESH_TOKEN_COOKIE_NAME];
    if (!refreshToken) {
      return setCookiesAndRedirectToHome(res, void 0, void 0);
    }
    const response = yield auth.user.logout(refreshToken);
    if (response.success) {
      return setCookiesAndRedirectToHome(res, void 0, void 0);
    } else {
      res.writeHead(500);
      res.end();
    }
  });
}
function parseUrlAndAddToReq(req) {
  var _a;
  if ((_a = req.url) == null ? void 0 : _a.startsWith("/")) {
    const parsedUrl = new URL(`http://localhost${req.url}`);
    const pathname = parsedUrl.pathname;
    const queryParams = parsedUrl.searchParams;
    req._pathname = pathname;
    req._queryParams = queryParams;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  initializeAuthProxy
});
//# sourceMappingURL=index.js.map