declare class UnauthorizedException extends Error {
    readonly message: string;
    readonly status: number;
    constructor(message: string);
}
declare class ConfigurationException extends Error {
    readonly message: string;
    readonly status: number;
    constructor(message: string);
}

declare class UserFromToken {
    userId: string;
    orgIdToOrgMemberInfo?: OrgIdToOrgMemberInfo;
    email: string;
    firstName?: string;
    lastName?: string;
    username?: string;
    properties?: {
        [key: string]: unknown;
    };
    legacyUserId?: string;
    impersonatorUserId?: string;
    constructor(userId: string, email: string, orgIdToOrgMemberInfo?: OrgIdToOrgMemberInfo, firstName?: string, lastName?: string, username?: string, legacyUserId?: string, impersonatorUserId?: string, properties?: {
        [key: string]: unknown;
    });
    getOrg(orgId: string): OrgMemberInfo | undefined;
    getOrgByName(orgName: string): OrgMemberInfo | undefined;
    getOrgs(): OrgMemberInfo[];
    isImpersonating(): boolean;
    isRole(orgId: string, role: string): boolean;
    isAtLeastRole(orgId: string, role: string): boolean;
    hasPermission(orgId: string, permission: string): boolean;
    hasAllPermissions(orgId: string, permissions: string[]): boolean;
    static fromJSON(json: string): UserFromToken;
}
type OrgIdToOrgMemberInfo = {
    [orgId: string]: OrgMemberInfo;
};
declare class OrgMemberInfo {
    orgId: string;
    orgName: string;
    orgMetadata: {
        [key: string]: any;
    };
    urlSafeOrgName: string;
    userAssignedRole: string;
    userInheritedRolesPlusCurrentRole: string[];
    userPermissions: string[];
    constructor(orgId: string, orgName: string, orgMetadata: {
        [key: string]: any;
    }, urlSafeOrgName: string, userAssignedRole: string, userInheritedRolesPlusCurrentRole: string[], userPermissions: string[]);
    isRole(role: string): boolean;
    isAtLeastRole(role: string): boolean;
    hasPermission(permission: string): boolean;
    hasAllPermissions(permissions: string[]): boolean;
    static fromJSON(json: string): OrgMemberInfo;
    get assignedRole(): string;
    get inheritedRolesPlusCurrentRole(): string[];
    get permissions(): string[];
}
type InternalOrgMemberInfo = {
    org_id: string;
    org_name: string;
    org_metadata: {
        [key: string]: any;
    };
    url_safe_org_name: string;
    user_role: string;
    inherited_user_roles_plus_current_role: string[];
    user_permissions: string[];
};
type InternalUser = {
    user_id: string;
    org_id_to_org_member_info?: {
        [org_id: string]: InternalOrgMemberInfo;
    };
    email: string;
    first_name?: string;
    last_name?: string;
    username?: string;
    properties?: {
        [key: string]: unknown;
    };
    legacy_user_id?: string;
    impersonator_user_id?: string;
};
declare function toUser(snake_case: InternalUser): UserFromToken;
declare function toOrgIdToOrgMemberInfo(snake_case?: {
    [org_id: string]: InternalOrgMemberInfo;
}): OrgIdToOrgMemberInfo | undefined;

type RefreshAndAccessTokens = {
    refreshToken: string;
    accessToken: string;
    accessTokenExpiresAtSeconds: number;
    error: 'none';
};
type RefreshAndAccessTokensUnauthorizedError = {
    error: 'unauthorized';
};
type RefreshAndAccessTokensUnexpectedError = {
    error: 'unexpected';
};
type RefreshTokenResponse = RefreshAndAccessTokens | RefreshAndAccessTokensUnauthorizedError | RefreshAndAccessTokensUnexpectedError;
declare function refreshAccessAndRefreshTokens(authUrl: URL, integrationApiKey: string, refreshToken: string): Promise<RefreshTokenResponse>;
declare function validateAccessTokenOrUndefined(authUrl: URL, verifierKey: string, accessToken: string | undefined): Promise<UserFromToken | undefined>;
declare function validateAccessToken(authUrl: URL, verifierKey: string, accessToken: string | undefined): Promise<UserFromToken>;

type LogoutResponse = {
    success: boolean;
};
declare function logout(authUrl: URL, integrationApiKey: string, refreshToken: string | undefined): Promise<LogoutResponse>;

interface RefreshUserInfoErrorResponse {
    error: true;
    error_type: 'unexpected' | 'unauthorized';
}
interface RefreshUserInfoSuccessResponse {
    error: false;
    accessToken: string;
    refreshToken: string;
    userInfo: UserInfo;
    impersonatorUserId: string | undefined;
}
type RefreshUserInfoResponse = RefreshUserInfoErrorResponse | RefreshUserInfoSuccessResponse;
declare function refreshUserInfo(authUrl: URL, integrationApiKey: string, verifierKey: string, oldRefreshToken: string | undefined): Promise<RefreshUserInfoResponse>;
type UserInfo = {
    user_id: string;
    email: string;
    email_confirmed: boolean;
    has_password: boolean;
    username?: string;
    first_name?: string;
    last_name?: string;
    picture_url?: string;
    properties?: {
        [key: string]: unknown;
    };
    locked: boolean;
    enabled: boolean;
    mfa_enabled: boolean;
    can_create_orgs: boolean;
    created_at: number;
    last_active_at: number;
    org_id_to_org_info?: {
        [org_id: string]: UserInOrgInfo;
    };
    legacy_user_id?: string;
    update_password_required: boolean;
};
type UserInOrgInfo = {
    org_id: string;
    org_name: string;
    org_metadata: {
        [key: string]: unknown;
    };
    url_safe_org_name: string;
    user_role: string;
    inherited_user_roles_plus_current_role: string[];
    user_permissions: string[];
};

interface SignupOrLoginHandlerResponse {
    authorizeUrl: string;
    state: string;
}
declare function signupOrLoginHandler(authUrl: URL, redirectUri: string, isSignup: boolean): SignupOrLoginHandlerResponse;

interface CallbackHandlerError {
    error: true;
    error_type: 'state_mismatch' | 'bad_config' | 'unexpected_error';
}
interface CallbackHandlerSuccess {
    error: false;
    accessToken: string;
    refreshToken: string;
}
type CallbackHandlerResponse = CallbackHandlerSuccess | CallbackHandlerError;
type CallbackHandlerArgs = {
    stateFromCookie: string | undefined;
    stateFromQueryParams: string | undefined;
    codeFromQueryParams: string | undefined;
};
declare function callbackHandler(authUrl: URL, integrationApiKey: string, redirectUri: string, { stateFromCookie, stateFromQueryParams, codeFromQueryParams }: CallbackHandlerArgs): Promise<CallbackHandlerResponse>;

interface InitAuthByFetchingProps {
    authUrl: string;
    integrationApiKey: string;
    redirectUri: string;
}
interface InitAuthProps extends InitAuthByFetchingProps {
    verifierKey: string;
}
declare function initAuthByFetchingConfig(props: InitAuthByFetchingProps): Promise<Auth>;
declare function initAuth(props: InitAuthProps): Auth;
interface PackageFunctionsProps {
    authUrl: URL;
    integrationApiKey: string;
    verifierKey: string;
    redirectUri: string;
}
interface Auth {
    validation: {
        validateAccessTokenOrUndefined: (accessToken: string | undefined) => Promise<UserFromToken | undefined>;
        validateAccessToken: (accessToken: string) => Promise<UserFromToken>;
    };
    token: {
        refreshTokens: (refreshToken: string) => Promise<RefreshTokenResponse>;
        getUserWithPossibleRefresh: (accessToken: string | undefined, refreshToken: string | undefined, forceRefresh?: boolean) => Promise<GetUserResponse>;
        refreshUserInfoAndTokens: (refreshToken: string | undefined) => Promise<RefreshUserInfoResponse>;
    };
    user: {
        redirectToSignupOrLogin: (isSignup: boolean) => SignupOrLoginHandlerResponse;
        finishLogin: (args: CallbackHandlerArgs) => Promise<CallbackHandlerResponse>;
        logout: (refreshToken: string | undefined) => Promise<LogoutResponse>;
    };
    args: PackageFunctionsProps;
}
type GetUserUnexpectedError = {
    error: 'unexpected';
};
type GetUserUnauthorizedError = {
    error: 'unauthorized';
};
type GetUserSuccessWithRefresh = {
    successType: 'WITH_REFRESH';
    user: UserFromToken;
    accessToken: string;
    accessTokenExpiresAtSeconds: number;
    refreshToken: string;
};
type GetUserSuccessWithoutRefresh = {
    successType: 'WITHOUT_REFRESH';
    user: UserFromToken;
};
type GetUserResponse = GetUserUnauthorizedError | GetUserUnexpectedError | GetUserSuccessWithRefresh | GetUserSuccessWithoutRefresh;
declare function getUserWithPossibleRefresh(authUrl: URL, integrationApiKey: string, verifierKey: string, accessToken: string | undefined, refreshToken: string | undefined, forceRefresh?: boolean): Promise<GetUserResponse>;

declare const REFRESH_COOKIE_NAME = "__pa_rt";
declare const ACCESS_COOKIE_NAME = "__pa_at";
declare const STATE_COOKIE_NAME = "__pa_state";
declare const RETURN_TO_PATH_COOKIE_NAME = "return-to-path";
declare const ACTIVE_ORG_ID_COOKIE_NAME = "active-org-id";

export { ACCESS_COOKIE_NAME, ACTIVE_ORG_ID_COOKIE_NAME, Auth, CallbackHandlerArgs, CallbackHandlerError, CallbackHandlerResponse, CallbackHandlerSuccess, ConfigurationException, GetUserResponse, GetUserSuccessWithRefresh, GetUserSuccessWithoutRefresh, GetUserUnauthorizedError, GetUserUnexpectedError, InitAuthByFetchingProps, InitAuthProps, InternalOrgMemberInfo, InternalUser, LogoutResponse, OrgIdToOrgMemberInfo, OrgMemberInfo, PackageFunctionsProps, REFRESH_COOKIE_NAME, RETURN_TO_PATH_COOKIE_NAME, RefreshAndAccessTokens, RefreshAndAccessTokensUnauthorizedError, RefreshAndAccessTokensUnexpectedError, RefreshTokenResponse, RefreshUserInfoErrorResponse, RefreshUserInfoResponse, RefreshUserInfoSuccessResponse, STATE_COOKIE_NAME, SignupOrLoginHandlerResponse, UnauthorizedException, UserFromToken, UserInOrgInfo, UserInfo, callbackHandler, getUserWithPossibleRefresh, initAuth, initAuthByFetchingConfig, logout, refreshAccessAndRefreshTokens, refreshUserInfo, signupOrLoginHandler, toOrgIdToOrgMemberInfo, toUser, validateAccessToken, validateAccessTokenOrUndefined };
