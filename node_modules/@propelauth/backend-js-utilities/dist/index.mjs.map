{"version":3,"sources":["../src/exceptions.ts","../src/user.ts","../src/tokens.ts","../src/logout.ts","../src/userinfo.ts","../src/verifier_key.ts","../src/login.ts","../src/callback.ts","../src/helpers.ts","../src/cookies.ts"],"sourcesContent":["export class UnauthorizedException extends Error {\n    readonly message: string\n    readonly status: number\n\n    constructor(message: string) {\n        super(message)\n        this.message = message\n        this.status = 401\n    }\n}\n\nexport class ConfigurationException extends Error {\n    readonly message: string\n    readonly status: number\n\n    constructor(message: string) {\n        super(message)\n        this.message = message\n        this.status = 500\n    }\n}\n","export class UserFromToken {\n    public userId: string\n    public orgIdToOrgMemberInfo?: OrgIdToOrgMemberInfo\n\n    // Metadata about the user\n    public email: string\n    public firstName?: string\n    public lastName?: string\n    public username?: string\n    public properties?: { [key: string]: unknown }\n\n    // If you used our migration APIs to migrate this user from a different system,\n    //   this is their original ID from that system.\n    public legacyUserId?: string\n    public impersonatorUserId?: string\n\n    constructor(\n        userId: string,\n        email: string,\n        orgIdToOrgMemberInfo?: OrgIdToOrgMemberInfo,\n        firstName?: string,\n        lastName?: string,\n        username?: string,\n        legacyUserId?: string,\n        impersonatorUserId?: string,\n        properties?: { [key: string]: unknown }\n    ) {\n        this.userId = userId\n        this.orgIdToOrgMemberInfo = orgIdToOrgMemberInfo\n\n        this.email = email\n        this.firstName = firstName\n        this.lastName = lastName\n        this.username = username\n\n        this.legacyUserId = legacyUserId\n        this.impersonatorUserId = impersonatorUserId\n\n        this.properties = properties\n    }\n\n    public getOrg(orgId: string): OrgMemberInfo | undefined {\n        if (!this.orgIdToOrgMemberInfo) {\n            return undefined\n        }\n\n        return this.orgIdToOrgMemberInfo[orgId]\n    }\n\n    public getOrgByName(orgName: string): OrgMemberInfo | undefined {\n        if (!this.orgIdToOrgMemberInfo) {\n            return undefined\n        }\n\n        const urlSafeOrgName = orgName.toLowerCase().replace(/ /g, '-')\n        for (const orgId in this.orgIdToOrgMemberInfo) {\n            const orgMemberInfo = this.orgIdToOrgMemberInfo[orgId]\n            if (orgMemberInfo.urlSafeOrgName === urlSafeOrgName) {\n                return orgMemberInfo\n            }\n        }\n\n        return undefined\n    }\n\n    public getOrgs(): OrgMemberInfo[] {\n        if (!this.orgIdToOrgMemberInfo) {\n            return []\n        }\n\n        return Object.values(this.orgIdToOrgMemberInfo).sort((a, b) => {\n            return a.orgName.localeCompare(b.orgName)\n        })\n    }\n\n    public isImpersonating(): boolean {\n        return !!this.impersonatorUserId\n    }\n\n    public isRole(orgId: string, role: string): boolean {\n        const orgMemberInfo = this.getOrg(orgId)\n        if (!orgMemberInfo) {\n            return false\n        }\n\n        return orgMemberInfo.isRole(role)\n    }\n\n    public isAtLeastRole(orgId: string, role: string): boolean {\n        const orgMemberInfo = this.getOrg(orgId)\n        if (!orgMemberInfo) {\n            return false\n        }\n\n        return orgMemberInfo.isAtLeastRole(role)\n    }\n\n    public hasPermission(orgId: string, permission: string): boolean {\n        const orgMemberInfo = this.getOrg(orgId)\n        if (!orgMemberInfo) {\n            return false\n        }\n\n        return orgMemberInfo.hasPermission(permission)\n    }\n\n    public hasAllPermissions(orgId: string, permissions: string[]): boolean {\n        const orgMemberInfo = this.getOrg(orgId)\n        if (!orgMemberInfo) {\n            return false\n        }\n\n        return orgMemberInfo.hasAllPermissions(permissions)\n    }\n\n    public static fromJSON(json: string): UserFromToken {\n        const obj = JSON.parse(json)\n        const orgIdToOrgMemberInfo: OrgIdToOrgMemberInfo = {}\n        for (const orgId in obj.orgIdToOrgMemberInfo) {\n            orgIdToOrgMemberInfo[orgId] = OrgMemberInfo.fromJSON(\n                JSON.stringify(obj.orgIdToOrgMemberInfo[orgId])\n            )\n        }\n        return new UserFromToken(\n            obj.userId,\n            obj.email,\n            orgIdToOrgMemberInfo,\n            obj.firstName,\n            obj.lastName,\n            obj.username,\n            obj.legacyUserId,\n            obj.impersonatorUserId,\n            obj.properties\n        )\n    }\n}\n\nexport type OrgIdToOrgMemberInfo = {\n    [orgId: string]: OrgMemberInfo\n}\n\nexport class OrgMemberInfo {\n    public orgId: string\n    public orgName: string\n    public orgMetadata: { [key: string]: any }\n    public urlSafeOrgName: string\n\n    public userAssignedRole: string\n    public userInheritedRolesPlusCurrentRole: string[]\n    public userPermissions: string[]\n\n    constructor(\n        orgId: string,\n        orgName: string,\n        orgMetadata: { [key: string]: any },\n        urlSafeOrgName: string,\n        userAssignedRole: string,\n        userInheritedRolesPlusCurrentRole: string[],\n        userPermissions: string[]\n    ) {\n        this.orgId = orgId\n        this.orgName = orgName\n        this.orgMetadata = orgMetadata\n        this.urlSafeOrgName = urlSafeOrgName\n\n        this.userAssignedRole = userAssignedRole\n        this.userInheritedRolesPlusCurrentRole =\n            userInheritedRolesPlusCurrentRole\n        this.userPermissions = userPermissions\n    }\n\n    // validation methods\n\n    public isRole(role: string): boolean {\n        return this.userAssignedRole === role\n    }\n\n    public isAtLeastRole(role: string): boolean {\n        return this.userInheritedRolesPlusCurrentRole.includes(role)\n    }\n\n    public hasPermission(permission: string): boolean {\n        return this.userPermissions.includes(permission)\n    }\n\n    public hasAllPermissions(permissions: string[]): boolean {\n        return permissions.every((permission) => this.hasPermission(permission))\n    }\n\n    public static fromJSON(json: string): OrgMemberInfo {\n        const obj = JSON.parse(json)\n        return new OrgMemberInfo(\n            obj.orgId,\n            obj.orgName,\n            obj.orgMetadata,\n            obj.urlSafeOrgName,\n            obj.userAssignedRole,\n            obj.userInheritedRolesPlusCurrentRole,\n            obj.userPermissions\n        )\n    }\n\n    get assignedRole(): string {\n        return this.userAssignedRole\n    }\n\n    get inheritedRolesPlusCurrentRole(): string[] {\n        return this.userInheritedRolesPlusCurrentRole\n    }\n\n    get permissions(): string[] {\n        return this.userPermissions\n    }\n}\n\n// These Internal types exist since the server returns snake case, but typescript/javascript\n// convention is camelCase.\nexport type InternalOrgMemberInfo = {\n    org_id: string\n    org_name: string\n    org_metadata: { [key: string]: any }\n    url_safe_org_name: string\n    user_role: string\n    inherited_user_roles_plus_current_role: string[]\n    user_permissions: string[]\n}\nexport type InternalUser = {\n    user_id: string\n    org_id_to_org_member_info?: { [org_id: string]: InternalOrgMemberInfo }\n\n    email: string\n    first_name?: string\n    last_name?: string\n    username?: string\n    properties?: { [key: string]: unknown }\n\n    // If you used our migration APIs to migrate this user from a different system, this is their original ID from that system.\n    legacy_user_id?: string\n    impersonator_user_id?: string\n}\n\nexport function toUser(snake_case: InternalUser): UserFromToken {\n    return new UserFromToken(\n        snake_case.user_id,\n        snake_case.email,\n        toOrgIdToOrgMemberInfo(snake_case.org_id_to_org_member_info),\n        snake_case.first_name,\n        snake_case.last_name,\n        snake_case.username,\n        snake_case.legacy_user_id,\n        snake_case.impersonator_user_id,\n        snake_case.properties\n    )\n}\n\nexport function toOrgIdToOrgMemberInfo(snake_case?: {\n    [org_id: string]: InternalOrgMemberInfo\n}): OrgIdToOrgMemberInfo | undefined {\n    if (snake_case === undefined) {\n        return undefined\n    }\n    const camelCase: OrgIdToOrgMemberInfo = {}\n\n    for (const key of Object.keys(snake_case)) {\n        const snakeCaseValue = snake_case[key]\n        if (snakeCaseValue) {\n            camelCase[key] = new OrgMemberInfo(\n                snakeCaseValue.org_id,\n                snakeCaseValue.org_name,\n                snakeCaseValue.org_metadata,\n                snakeCaseValue.url_safe_org_name,\n                snakeCaseValue.user_role,\n                snakeCaseValue.inherited_user_roles_plus_current_role,\n                snakeCaseValue.user_permissions\n            )\n        }\n    }\n\n    return camelCase\n}\n","import { InternalUser, toUser, UserFromToken } from './user'\nimport { ConfigurationException, UnauthorizedException } from './exceptions'\nimport * as jose from 'jose'\n\nexport type RefreshAndAccessTokens = {\n    refreshToken: string\n    accessToken: string\n    accessTokenExpiresAtSeconds: number\n    error: 'none'\n}\n\nexport type RefreshAndAccessTokensUnauthorizedError = {\n    error: 'unauthorized'\n}\n\nexport type RefreshAndAccessTokensUnexpectedError = {\n    error: 'unexpected'\n}\n\nexport type RefreshTokenResponse =\n    | RefreshAndAccessTokens\n    | RefreshAndAccessTokensUnauthorizedError\n    | RefreshAndAccessTokensUnexpectedError\n\nexport async function refreshAccessAndRefreshTokens(\n    authUrl: URL,\n    integrationApiKey: string,\n    refreshToken: string\n): Promise<RefreshTokenResponse> {\n    const authUrlOrigin = authUrl.origin\n    const body = {\n        refresh_token: refreshToken,\n    }\n    const url = `${authUrlOrigin}/api/backend/v1/refresh_token`\n    const response = await fetch(url, {\n        method: 'POST',\n        body: JSON.stringify(body),\n        headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${integrationApiKey}`,\n        },\n    })\n\n    if (response.ok) {\n        const data = await response.json()\n        const newRefreshToken = data.refresh_token\n        const {\n            access_token: accessToken,\n            expires_at_seconds: expiresAtSeconds,\n        } = data.access_token\n\n        return {\n            refreshToken: newRefreshToken,\n            accessToken,\n            accessTokenExpiresAtSeconds: expiresAtSeconds,\n            error: 'none',\n        }\n    } else if (response.status === 400 || response.status === 401) {\n        return { error: 'unauthorized' }\n    } else {\n        return { error: 'unexpected' }\n    }\n}\n\nexport async function validateAccessTokenOrUndefined(\n    authUrl: URL,\n    verifierKey: string,\n    accessToken: string | undefined\n): Promise<UserFromToken | undefined> {\n    try {\n        return await validateAccessToken(authUrl, verifierKey, accessToken)\n    } catch (err) {\n        if (err instanceof ConfigurationException) {\n            throw err\n        } else if (err instanceof UnauthorizedException) {\n            return undefined\n        } else {\n            console.info('Error validating access token', err)\n            return undefined\n        }\n    }\n}\n\nexport async function validateAccessToken(\n    authUrl: URL,\n    verifierKey: string,\n    accessToken: string | undefined\n): Promise<UserFromToken> {\n    let publicKey\n    try {\n        publicKey = await jose.importSPKI(verifierKey, 'RS256')\n    } catch (err) {\n        console.error(\n            \"Verifier key is invalid. Make sure it's specified correctly, including the newlines.\",\n            err\n        )\n        throw new ConfigurationException('Invalid verifier key')\n    }\n\n    if (!accessToken) {\n        throw new UnauthorizedException('No access token provided')\n    }\n\n    let accessTokenWithoutBearer = accessToken\n    if (accessToken.toLowerCase().startsWith('bearer ')) {\n        accessTokenWithoutBearer = accessToken.substring('bearer '.length)\n    }\n\n    try {\n        const { payload } = await jose.jwtVerify(\n            accessTokenWithoutBearer,\n            publicKey,\n            {\n                issuer: authUrl.origin,\n                algorithms: ['RS256'],\n            }\n        )\n\n        return toUser(<InternalUser>payload)\n    } catch (e) {\n        if (e instanceof Error) {\n            throw new UnauthorizedException(e.message)\n        } else {\n            throw new UnauthorizedException('Unable to decode jwt')\n        }\n    }\n}\n","export type LogoutResponse = {\n    success: boolean\n}\n\n// Callers of this function will need to clear cookies themselves\nexport async function logout(\n    authUrl: URL,\n    integrationApiKey: string,\n    refreshToken: string | undefined\n): Promise<LogoutResponse> {\n    if (!refreshToken) {\n        return { success: false }\n    }\n\n    const logoutBody = { refresh_token: refreshToken }\n    const url = `${authUrl.origin}/api/backend/v1/logout`\n    const response = await fetch(url, {\n        method: 'POST',\n        body: JSON.stringify(logoutBody),\n        headers: {\n            'Content-Type': 'application/json',\n            Authorization: 'Bearer ' + integrationApiKey,\n        },\n    })\n\n    return { success: response.ok }\n}\n","import { refreshAccessAndRefreshTokens, validateAccessToken } from './tokens'\n\nexport interface RefreshUserInfoErrorResponse {\n    error: true\n    error_type: 'unexpected' | 'unauthorized'\n}\n\nexport interface RefreshUserInfoSuccessResponse {\n    error: false\n    accessToken: string\n    refreshToken: string\n    userInfo: UserInfo\n    impersonatorUserId: string | undefined\n}\n\nexport type RefreshUserInfoResponse =\n    | RefreshUserInfoErrorResponse\n    | RefreshUserInfoSuccessResponse\n\nexport async function refreshUserInfo(\n    authUrl: URL,\n    integrationApiKey: string,\n    verifierKey: string,\n    oldRefreshToken: string | undefined\n): Promise<RefreshUserInfoResponse> {\n    if (!oldRefreshToken) {\n        return { error: true, error_type: 'unauthorized' }\n    }\n\n    // For the userinfo endpoint, we want to get the most up-to-date info, so we'll refresh the access token\n    const refreshResponse = await refreshAccessAndRefreshTokens(\n        authUrl,\n        integrationApiKey,\n        oldRefreshToken\n    )\n    if (refreshResponse.error === 'unexpected') {\n        return { error: true, error_type: 'unexpected' }\n    } else if (refreshResponse.error === 'unauthorized') {\n        return { error: true, error_type: 'unauthorized' }\n    }\n\n    const refreshToken = refreshResponse.refreshToken\n    const accessToken = refreshResponse.accessToken\n\n    const path = `${authUrl.origin}/propelauth/oauth/userinfo`\n    const response = await fetch(path, {\n        headers: {\n            'Content-Type': 'application/json',\n            Authorization: 'Bearer ' + accessToken,\n        },\n    })\n    if (response.ok) {\n        const userFromToken = await validateAccessToken(\n            authUrl,\n            verifierKey,\n            accessToken\n        )\n        const data = await response.json()\n\n        return {\n            error: false,\n            accessToken,\n            refreshToken,\n            userInfo: data,\n            impersonatorUserId: userFromToken.impersonatorUserId,\n        }\n    } else if (response.status === 401) {\n        return { error: true, error_type: 'unauthorized' }\n    } else {\n        return { error: true, error_type: 'unexpected' }\n    }\n}\n\nexport type UserInfo = {\n    user_id: string\n\n    email: string\n    email_confirmed: boolean\n    has_password: boolean\n\n    username?: string\n    first_name?: string\n    last_name?: string\n    picture_url?: string\n    properties?: { [key: string]: unknown }\n\n    locked: boolean\n    enabled: boolean\n    mfa_enabled: boolean\n    can_create_orgs: boolean\n\n    created_at: number\n    last_active_at: number\n\n    org_id_to_org_info?: { [org_id: string]: UserInOrgInfo }\n\n    legacy_user_id?: string\n\n    update_password_required: boolean\n}\n\nexport type UserInOrgInfo = {\n    org_id: string\n    org_name: string\n    org_metadata: { [key: string]: unknown }\n    url_safe_org_name: string\n    user_role: string\n    inherited_user_roles_plus_current_role: string[]\n    user_permissions: string[]\n}\n","export type TokenVerificationMetadata = {\n    verifierKey: string\n}\n\nexport async function fetchTokenVerificationMetadata(\n    authUrl: URL,\n    integrationApiKey: string\n): Promise<TokenVerificationMetadata> {\n    const url = `${authUrl.origin}/api/v1/token_verification_metadata`\n\n    const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n            'Content-Type': 'application/json',\n            Authorization: 'Bearer ' + integrationApiKey,\n        },\n    })\n\n    if (response.ok) {\n        const data = await response.json()\n        return {\n            verifierKey: data.verifier_key_pem,\n        }\n    } else if (response.status === 401) {\n        throw new Error('integrationApiKey is incorrect')\n    } else {\n        throw new Error(\n            'Unknown error when fetching token verification metadata'\n        )\n    }\n}\n","import crypto from 'node:crypto'\n\nexport interface SignupOrLoginHandlerResponse {\n    authorizeUrl: string\n    state: string\n}\n\nexport function signupOrLoginHandler(\n    authUrl: URL,\n    redirectUri: string,\n    isSignup: boolean\n): SignupOrLoginHandlerResponse {\n    const authUrlOrigin = authUrl.origin\n    const state = randomState()\n\n    const authorizeUrlSearchParams = new URLSearchParams({\n        redirect_uri: redirectUri,\n        state,\n        signup: isSignup ? 'true' : 'false',\n    })\n    const authorizeUrl = authUrlOrigin + '/propelauth/ssr/authorize?' + authorizeUrlSearchParams.toString()\n\n    return {\n        authorizeUrl,\n        state,\n    }\n}\n\nfunction randomState(): string {\n    const randomBytes = crypto.webcrypto.getRandomValues(new Uint8Array(32))\n    return Array.from(randomBytes)\n        .map((b) => (b as number).toString(16).padStart(2, '0'))\n        .join('')\n}\n","export interface CallbackHandlerError {\n    error: true\n    error_type: 'state_mismatch' | 'bad_config' | 'unexpected_error'\n}\n\nexport interface CallbackHandlerSuccess {\n    error: false\n    accessToken: string\n    refreshToken: string\n}\n\nexport type CallbackHandlerResponse = CallbackHandlerSuccess | CallbackHandlerError\n\nexport type CallbackHandlerArgs = {\n    stateFromCookie: string | undefined\n    stateFromQueryParams: string | undefined\n    codeFromQueryParams: string | undefined\n}\n\nexport async function callbackHandler(\n    authUrl: URL,\n    integrationApiKey: string,\n    redirectUri: string,\n    { stateFromCookie, stateFromQueryParams, codeFromQueryParams }: CallbackHandlerArgs\n): Promise<CallbackHandlerResponse> {\n    if (!stateFromCookie || stateFromCookie.length !== 64) {\n        return { error: true, error_type: 'state_mismatch' }\n    }\n\n    if (stateFromQueryParams !== stateFromCookie) {\n        return { error: true, error_type: 'state_mismatch' }\n    }\n\n    const oauth_token_body = {\n        redirect_uri: redirectUri,\n        code: codeFromQueryParams,\n    }\n    const url = `${authUrl.origin}/propelauth/ssr/token`\n    const response = await fetch(url, {\n        method: 'POST',\n        body: JSON.stringify(oauth_token_body),\n        headers: {\n            'Content-Type': 'application/json',\n            Authorization: 'Bearer ' + integrationApiKey,\n        },\n    })\n\n    if (response.ok) {\n        const data = await response.json()\n\n        return {\n            error: false,\n            accessToken: data.access_token,\n            refreshToken: data.refresh_token,\n        }\n    } else if (response.status === 401) {\n        return { error: true, error_type: 'bad_config' }\n    } else {\n        return { error: true, error_type: 'unexpected_error' }\n    }\n}\n","import {\n    refreshAccessAndRefreshTokens,\n    RefreshTokenResponse,\n    validateAccessToken,\n    validateAccessTokenOrUndefined,\n} from './tokens'\nimport { UserFromToken } from './user'\nimport { logout, LogoutResponse } from './logout'\nimport { refreshUserInfo, RefreshUserInfoResponse } from './userinfo'\nimport { fetchTokenVerificationMetadata } from './verifier_key'\nimport { signupOrLoginHandler, SignupOrLoginHandlerResponse } from './login'\nimport { callbackHandler, CallbackHandlerArgs, CallbackHandlerResponse } from './callback'\n\nexport interface InitAuthByFetchingProps {\n    authUrl: string\n    integrationApiKey: string\n    redirectUri: string\n}\n\nexport interface InitAuthProps extends InitAuthByFetchingProps {\n    verifierKey: string\n}\n\nconst validateUrl = (authUrl: string, type: string) => {\n    try {\n        return new URL(authUrl)\n    } catch (e) {\n        throw new Error(`Invalid ${type} URL`)\n    }\n}\n\nexport async function initAuthByFetchingConfig(props: InitAuthByFetchingProps): Promise<Auth> {\n    const authUrl = validateUrl(props.authUrl, 'auth')\n    const tokenVerificationMetadata = await fetchTokenVerificationMetadata(authUrl, props.integrationApiKey)\n    return packageFunctions({\n        authUrl,\n        integrationApiKey: props.integrationApiKey,\n        verifierKey: tokenVerificationMetadata.verifierKey,\n        redirectUri: props.redirectUri,\n    })\n}\n\nexport function initAuth(props: InitAuthProps): Auth {\n    const authUrl = validateUrl(props.authUrl, 'auth')\n    return packageFunctions({\n        authUrl,\n        integrationApiKey: props.integrationApiKey,\n        verifierKey: props.verifierKey,\n        redirectUri: props.redirectUri,\n    })\n}\n\nexport interface PackageFunctionsProps {\n    authUrl: URL\n    integrationApiKey: string\n    verifierKey: string\n    redirectUri: string\n}\n\nexport interface Auth {\n    validation: {\n        validateAccessTokenOrUndefined: (accessToken: string | undefined) => Promise<UserFromToken | undefined>\n        validateAccessToken: (accessToken: string) => Promise<UserFromToken>\n    }\n    token: {\n        refreshTokens: (refreshToken: string) => Promise<RefreshTokenResponse>\n        getUserWithPossibleRefresh: (\n            accessToken: string | undefined,\n            refreshToken: string | undefined,\n            forceRefresh?: boolean\n        ) => Promise<GetUserResponse>\n        refreshUserInfoAndTokens: (refreshToken: string | undefined) => Promise<RefreshUserInfoResponse>\n    }\n    user: {\n        redirectToSignupOrLogin: (isSignup: boolean) => SignupOrLoginHandlerResponse\n        finishLogin: (args: CallbackHandlerArgs) => Promise<CallbackHandlerResponse>\n        logout: (refreshToken: string | undefined) => Promise<LogoutResponse>\n    }\n    args: PackageFunctionsProps\n}\n\nfunction packageFunctions({ authUrl, integrationApiKey, verifierKey, redirectUri }: PackageFunctionsProps): Auth {\n    return {\n        validation: {\n            validateAccessTokenOrUndefined: (accessToken: string | undefined) =>\n                validateAccessTokenOrUndefined(authUrl, verifierKey, accessToken),\n            validateAccessToken: (accessToken: string) => validateAccessToken(authUrl, verifierKey, accessToken),\n        },\n        token: {\n            refreshTokens: (refreshToken: string) =>\n                refreshAccessAndRefreshTokens(authUrl, integrationApiKey, refreshToken),\n            getUserWithPossibleRefresh: (\n                accessToken: string | undefined,\n                refreshToken: string | undefined,\n                forceRefresh: boolean = false\n            ) =>\n                getUserWithPossibleRefresh(\n                    authUrl,\n                    integrationApiKey,\n                    verifierKey,\n                    accessToken,\n                    refreshToken,\n                    forceRefresh\n                ),\n            refreshUserInfoAndTokens: (refreshToken: string | undefined) =>\n                refreshUserInfo(authUrl, integrationApiKey, verifierKey, refreshToken),\n        },\n        user: {\n            redirectToSignupOrLogin: (isSignup: boolean) => signupOrLoginHandler(authUrl, redirectUri, isSignup),\n            finishLogin: (args: CallbackHandlerArgs) => callbackHandler(authUrl, integrationApiKey, redirectUri, args),\n            logout: (refreshToken: string | undefined) => logout(authUrl, integrationApiKey, refreshToken),\n        },\n        args: {\n            authUrl,\n            integrationApiKey,\n            verifierKey,\n            redirectUri,\n        },\n    }\n}\n\nexport type GetUserUnexpectedError = {\n    error: 'unexpected'\n}\n\nexport type GetUserUnauthorizedError = {\n    error: 'unauthorized'\n}\n\nexport type GetUserSuccessWithRefresh = {\n    successType: 'WITH_REFRESH'\n    user: UserFromToken\n    accessToken: string\n    accessTokenExpiresAtSeconds: number\n    refreshToken: string\n}\n\nexport type GetUserSuccessWithoutRefresh = {\n    successType: 'WITHOUT_REFRESH'\n    user: UserFromToken\n}\n\nexport type GetUserResponse =\n    | GetUserUnauthorizedError\n    | GetUserUnexpectedError\n    | GetUserSuccessWithRefresh\n    | GetUserSuccessWithoutRefresh\n\nexport async function getUserWithPossibleRefresh(\n    authUrl: URL,\n    integrationApiKey: string,\n    verifierKey: string,\n    accessToken: string | undefined,\n    refreshToken: string | undefined,\n    forceRefresh: boolean = false\n): Promise<GetUserResponse> {\n    // If we are authenticated, we can continue\n    if (accessToken && !forceRefresh) {\n        const user = await validateAccessTokenOrUndefined(authUrl, verifierKey, accessToken)\n        if (user) {\n            return {\n                successType: 'WITHOUT_REFRESH',\n                user,\n            }\n        }\n    }\n\n    // Otherwise, we need to refresh the access token\n    if (refreshToken) {\n        const response = await refreshAccessAndRefreshTokens(authUrl, integrationApiKey, refreshToken)\n        if (response.error === 'unexpected') {\n            return { error: 'unexpected' }\n        } else if (response.error === 'unauthorized') {\n            return { error: 'unauthorized' }\n        } else {\n            const user = await validateAccessToken(authUrl, verifierKey, response.accessToken)\n            return {\n                successType: 'WITH_REFRESH',\n                user,\n                accessToken: response.accessToken,\n                accessTokenExpiresAtSeconds: response.accessTokenExpiresAtSeconds,\n                refreshToken: response.refreshToken,\n            }\n        }\n    }\n\n    return { error: 'unauthorized' }\n}\n","export const REFRESH_COOKIE_NAME = \"__pa_rt\"\nexport const ACCESS_COOKIE_NAME = \"__pa_at\"\nexport const STATE_COOKIE_NAME = \"__pa_state\"\nexport const RETURN_TO_PATH_COOKIE_NAME = \"return-to-path\"\nexport const ACTIVE_ORG_ID_COOKIE_NAME = \"active-org-id\"\n"],"mappings":"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","names":[]}