var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/exceptions.ts
var UnauthorizedException = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.status = 401;
  }
};
var ConfigurationException = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.status = 500;
  }
};

// src/user.ts
var UserFromToken = class _UserFromToken {
  constructor(userId, email, orgIdToOrgMemberInfo, firstName, lastName, username, legacyUserId, impersonatorUserId, properties) {
    this.userId = userId;
    this.orgIdToOrgMemberInfo = orgIdToOrgMemberInfo;
    this.email = email;
    this.firstName = firstName;
    this.lastName = lastName;
    this.username = username;
    this.legacyUserId = legacyUserId;
    this.impersonatorUserId = impersonatorUserId;
    this.properties = properties;
  }
  getOrg(orgId) {
    if (!this.orgIdToOrgMemberInfo) {
      return void 0;
    }
    return this.orgIdToOrgMemberInfo[orgId];
  }
  getOrgByName(orgName) {
    if (!this.orgIdToOrgMemberInfo) {
      return void 0;
    }
    const urlSafeOrgName = orgName.toLowerCase().replace(/ /g, "-");
    for (const orgId in this.orgIdToOrgMemberInfo) {
      const orgMemberInfo = this.orgIdToOrgMemberInfo[orgId];
      if (orgMemberInfo.urlSafeOrgName === urlSafeOrgName) {
        return orgMemberInfo;
      }
    }
    return void 0;
  }
  getOrgs() {
    if (!this.orgIdToOrgMemberInfo) {
      return [];
    }
    return Object.values(this.orgIdToOrgMemberInfo).sort((a, b) => {
      return a.orgName.localeCompare(b.orgName);
    });
  }
  isImpersonating() {
    return !!this.impersonatorUserId;
  }
  isRole(orgId, role) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.isRole(role);
  }
  isAtLeastRole(orgId, role) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.isAtLeastRole(role);
  }
  hasPermission(orgId, permission) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.hasPermission(permission);
  }
  hasAllPermissions(orgId, permissions) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.hasAllPermissions(permissions);
  }
  static fromJSON(json) {
    const obj = JSON.parse(json);
    const orgIdToOrgMemberInfo = {};
    for (const orgId in obj.orgIdToOrgMemberInfo) {
      orgIdToOrgMemberInfo[orgId] = OrgMemberInfo.fromJSON(
        JSON.stringify(obj.orgIdToOrgMemberInfo[orgId])
      );
    }
    return new _UserFromToken(
      obj.userId,
      obj.email,
      orgIdToOrgMemberInfo,
      obj.firstName,
      obj.lastName,
      obj.username,
      obj.legacyUserId,
      obj.impersonatorUserId,
      obj.properties
    );
  }
};
var OrgMemberInfo = class _OrgMemberInfo {
  constructor(orgId, orgName, orgMetadata, urlSafeOrgName, userAssignedRole, userInheritedRolesPlusCurrentRole, userPermissions) {
    this.orgId = orgId;
    this.orgName = orgName;
    this.orgMetadata = orgMetadata;
    this.urlSafeOrgName = urlSafeOrgName;
    this.userAssignedRole = userAssignedRole;
    this.userInheritedRolesPlusCurrentRole = userInheritedRolesPlusCurrentRole;
    this.userPermissions = userPermissions;
  }
  // validation methods
  isRole(role) {
    return this.userAssignedRole === role;
  }
  isAtLeastRole(role) {
    return this.userInheritedRolesPlusCurrentRole.includes(role);
  }
  hasPermission(permission) {
    return this.userPermissions.includes(permission);
  }
  hasAllPermissions(permissions) {
    return permissions.every((permission) => this.hasPermission(permission));
  }
  static fromJSON(json) {
    const obj = JSON.parse(json);
    return new _OrgMemberInfo(
      obj.orgId,
      obj.orgName,
      obj.orgMetadata,
      obj.urlSafeOrgName,
      obj.userAssignedRole,
      obj.userInheritedRolesPlusCurrentRole,
      obj.userPermissions
    );
  }
  get assignedRole() {
    return this.userAssignedRole;
  }
  get inheritedRolesPlusCurrentRole() {
    return this.userInheritedRolesPlusCurrentRole;
  }
  get permissions() {
    return this.userPermissions;
  }
};
function toUser(snake_case) {
  return new UserFromToken(
    snake_case.user_id,
    snake_case.email,
    toOrgIdToOrgMemberInfo(snake_case.org_id_to_org_member_info),
    snake_case.first_name,
    snake_case.last_name,
    snake_case.username,
    snake_case.legacy_user_id,
    snake_case.impersonator_user_id,
    snake_case.properties
  );
}
function toOrgIdToOrgMemberInfo(snake_case) {
  if (snake_case === void 0) {
    return void 0;
  }
  const camelCase = {};
  for (const key of Object.keys(snake_case)) {
    const snakeCaseValue = snake_case[key];
    if (snakeCaseValue) {
      camelCase[key] = new OrgMemberInfo(
        snakeCaseValue.org_id,
        snakeCaseValue.org_name,
        snakeCaseValue.org_metadata,
        snakeCaseValue.url_safe_org_name,
        snakeCaseValue.user_role,
        snakeCaseValue.inherited_user_roles_plus_current_role,
        snakeCaseValue.user_permissions
      );
    }
  }
  return camelCase;
}

// src/tokens.ts
import * as jose from "jose";
function refreshAccessAndRefreshTokens(authUrl, integrationApiKey, refreshToken) {
  return __async(this, null, function* () {
    const authUrlOrigin = authUrl.origin;
    const body = {
      refresh_token: refreshToken
    };
    const url = `${authUrlOrigin}/api/backend/v1/refresh_token`;
    const response = yield fetch(url, {
      method: "POST",
      body: JSON.stringify(body),
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${integrationApiKey}`
      }
    });
    if (response.ok) {
      const data = yield response.json();
      const newRefreshToken = data.refresh_token;
      const {
        access_token: accessToken,
        expires_at_seconds: expiresAtSeconds
      } = data.access_token;
      return {
        refreshToken: newRefreshToken,
        accessToken,
        accessTokenExpiresAtSeconds: expiresAtSeconds,
        error: "none"
      };
    } else if (response.status === 400 || response.status === 401) {
      return { error: "unauthorized" };
    } else {
      return { error: "unexpected" };
    }
  });
}
function validateAccessTokenOrUndefined(authUrl, verifierKey, accessToken) {
  return __async(this, null, function* () {
    try {
      return yield validateAccessToken(authUrl, verifierKey, accessToken);
    } catch (err) {
      if (err instanceof ConfigurationException) {
        throw err;
      } else if (err instanceof UnauthorizedException) {
        return void 0;
      } else {
        console.info("Error validating access token", err);
        return void 0;
      }
    }
  });
}
function validateAccessToken(authUrl, verifierKey, accessToken) {
  return __async(this, null, function* () {
    let publicKey;
    try {
      publicKey = yield jose.importSPKI(verifierKey, "RS256");
    } catch (err) {
      console.error(
        "Verifier key is invalid. Make sure it's specified correctly, including the newlines.",
        err
      );
      throw new ConfigurationException("Invalid verifier key");
    }
    if (!accessToken) {
      throw new UnauthorizedException("No access token provided");
    }
    let accessTokenWithoutBearer = accessToken;
    if (accessToken.toLowerCase().startsWith("bearer ")) {
      accessTokenWithoutBearer = accessToken.substring("bearer ".length);
    }
    try {
      const { payload } = yield jose.jwtVerify(
        accessTokenWithoutBearer,
        publicKey,
        {
          issuer: authUrl.origin,
          algorithms: ["RS256"]
        }
      );
      return toUser(payload);
    } catch (e) {
      if (e instanceof Error) {
        throw new UnauthorizedException(e.message);
      } else {
        throw new UnauthorizedException("Unable to decode jwt");
      }
    }
  });
}

// src/logout.ts
function logout(authUrl, integrationApiKey, refreshToken) {
  return __async(this, null, function* () {
    if (!refreshToken) {
      return { success: false };
    }
    const logoutBody = { refresh_token: refreshToken };
    const url = `${authUrl.origin}/api/backend/v1/logout`;
    const response = yield fetch(url, {
      method: "POST",
      body: JSON.stringify(logoutBody),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + integrationApiKey
      }
    });
    return { success: response.ok };
  });
}

// src/userinfo.ts
function refreshUserInfo(authUrl, integrationApiKey, verifierKey, oldRefreshToken) {
  return __async(this, null, function* () {
    if (!oldRefreshToken) {
      return { error: true, error_type: "unauthorized" };
    }
    const refreshResponse = yield refreshAccessAndRefreshTokens(
      authUrl,
      integrationApiKey,
      oldRefreshToken
    );
    if (refreshResponse.error === "unexpected") {
      return { error: true, error_type: "unexpected" };
    } else if (refreshResponse.error === "unauthorized") {
      return { error: true, error_type: "unauthorized" };
    }
    const refreshToken = refreshResponse.refreshToken;
    const accessToken = refreshResponse.accessToken;
    const path = `${authUrl.origin}/propelauth/oauth/userinfo`;
    const response = yield fetch(path, {
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + accessToken
      }
    });
    if (response.ok) {
      const userFromToken = yield validateAccessToken(
        authUrl,
        verifierKey,
        accessToken
      );
      const data = yield response.json();
      return {
        error: false,
        accessToken,
        refreshToken,
        userInfo: data,
        impersonatorUserId: userFromToken.impersonatorUserId
      };
    } else if (response.status === 401) {
      return { error: true, error_type: "unauthorized" };
    } else {
      return { error: true, error_type: "unexpected" };
    }
  });
}

// src/verifier_key.ts
function fetchTokenVerificationMetadata(authUrl, integrationApiKey) {
  return __async(this, null, function* () {
    const url = `${authUrl.origin}/api/v1/token_verification_metadata`;
    const response = yield fetch(url, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + integrationApiKey
      }
    });
    if (response.ok) {
      const data = yield response.json();
      return {
        verifierKey: data.verifier_key_pem
      };
    } else if (response.status === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else {
      throw new Error(
        "Unknown error when fetching token verification metadata"
      );
    }
  });
}

// src/login.ts
import crypto from "crypto";
function signupOrLoginHandler(authUrl, redirectUri, isSignup) {
  const authUrlOrigin = authUrl.origin;
  const state = randomState();
  const authorizeUrlSearchParams = new URLSearchParams({
    redirect_uri: redirectUri,
    state,
    signup: isSignup ? "true" : "false"
  });
  const authorizeUrl = authUrlOrigin + "/propelauth/ssr/authorize?" + authorizeUrlSearchParams.toString();
  return {
    authorizeUrl,
    state
  };
}
function randomState() {
  const randomBytes = crypto.webcrypto.getRandomValues(new Uint8Array(32));
  return Array.from(randomBytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

// src/callback.ts
function callbackHandler(_0, _1, _2, _3) {
  return __async(this, arguments, function* (authUrl, integrationApiKey, redirectUri, { stateFromCookie, stateFromQueryParams, codeFromQueryParams }) {
    if (!stateFromCookie || stateFromCookie.length !== 64) {
      return { error: true, error_type: "state_mismatch" };
    }
    if (stateFromQueryParams !== stateFromCookie) {
      return { error: true, error_type: "state_mismatch" };
    }
    const oauth_token_body = {
      redirect_uri: redirectUri,
      code: codeFromQueryParams
    };
    const url = `${authUrl.origin}/propelauth/ssr/token`;
    const response = yield fetch(url, {
      method: "POST",
      body: JSON.stringify(oauth_token_body),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + integrationApiKey
      }
    });
    if (response.ok) {
      const data = yield response.json();
      return {
        error: false,
        accessToken: data.access_token,
        refreshToken: data.refresh_token
      };
    } else if (response.status === 401) {
      return { error: true, error_type: "bad_config" };
    } else {
      return { error: true, error_type: "unexpected_error" };
    }
  });
}

// src/helpers.ts
var validateUrl = (authUrl, type) => {
  try {
    return new URL(authUrl);
  } catch (e) {
    throw new Error(`Invalid ${type} URL`);
  }
};
function initAuthByFetchingConfig(props) {
  return __async(this, null, function* () {
    const authUrl = validateUrl(props.authUrl, "auth");
    const tokenVerificationMetadata = yield fetchTokenVerificationMetadata(authUrl, props.integrationApiKey);
    return packageFunctions({
      authUrl,
      integrationApiKey: props.integrationApiKey,
      verifierKey: tokenVerificationMetadata.verifierKey,
      redirectUri: props.redirectUri
    });
  });
}
function initAuth(props) {
  const authUrl = validateUrl(props.authUrl, "auth");
  return packageFunctions({
    authUrl,
    integrationApiKey: props.integrationApiKey,
    verifierKey: props.verifierKey,
    redirectUri: props.redirectUri
  });
}
function packageFunctions({ authUrl, integrationApiKey, verifierKey, redirectUri }) {
  return {
    validation: {
      validateAccessTokenOrUndefined: (accessToken) => validateAccessTokenOrUndefined(authUrl, verifierKey, accessToken),
      validateAccessToken: (accessToken) => validateAccessToken(authUrl, verifierKey, accessToken)
    },
    token: {
      refreshTokens: (refreshToken) => refreshAccessAndRefreshTokens(authUrl, integrationApiKey, refreshToken),
      getUserWithPossibleRefresh: (accessToken, refreshToken, forceRefresh = false) => getUserWithPossibleRefresh(
        authUrl,
        integrationApiKey,
        verifierKey,
        accessToken,
        refreshToken,
        forceRefresh
      ),
      refreshUserInfoAndTokens: (refreshToken) => refreshUserInfo(authUrl, integrationApiKey, verifierKey, refreshToken)
    },
    user: {
      redirectToSignupOrLogin: (isSignup) => signupOrLoginHandler(authUrl, redirectUri, isSignup),
      finishLogin: (args) => callbackHandler(authUrl, integrationApiKey, redirectUri, args),
      logout: (refreshToken) => logout(authUrl, integrationApiKey, refreshToken)
    },
    args: {
      authUrl,
      integrationApiKey,
      verifierKey,
      redirectUri
    }
  };
}
function getUserWithPossibleRefresh(authUrl, integrationApiKey, verifierKey, accessToken, refreshToken, forceRefresh = false) {
  return __async(this, null, function* () {
    if (accessToken && !forceRefresh) {
      const user = yield validateAccessTokenOrUndefined(authUrl, verifierKey, accessToken);
      if (user) {
        return {
          successType: "WITHOUT_REFRESH",
          user
        };
      }
    }
    if (refreshToken) {
      const response = yield refreshAccessAndRefreshTokens(authUrl, integrationApiKey, refreshToken);
      if (response.error === "unexpected") {
        return { error: "unexpected" };
      } else if (response.error === "unauthorized") {
        return { error: "unauthorized" };
      } else {
        const user = yield validateAccessToken(authUrl, verifierKey, response.accessToken);
        return {
          successType: "WITH_REFRESH",
          user,
          accessToken: response.accessToken,
          accessTokenExpiresAtSeconds: response.accessTokenExpiresAtSeconds,
          refreshToken: response.refreshToken
        };
      }
    }
    return { error: "unauthorized" };
  });
}

// src/cookies.ts
var REFRESH_COOKIE_NAME = "__pa_rt";
var ACCESS_COOKIE_NAME = "__pa_at";
var STATE_COOKIE_NAME = "__pa_state";
var RETURN_TO_PATH_COOKIE_NAME = "return-to-path";
var ACTIVE_ORG_ID_COOKIE_NAME = "active-org-id";
export {
  ACCESS_COOKIE_NAME,
  ACTIVE_ORG_ID_COOKIE_NAME,
  ConfigurationException,
  OrgMemberInfo,
  REFRESH_COOKIE_NAME,
  RETURN_TO_PATH_COOKIE_NAME,
  STATE_COOKIE_NAME,
  UnauthorizedException,
  UserFromToken,
  callbackHandler,
  getUserWithPossibleRefresh,
  initAuth,
  initAuthByFetchingConfig,
  logout,
  refreshAccessAndRefreshTokens,
  refreshUserInfo,
  signupOrLoginHandler,
  toOrgIdToOrgMemberInfo,
  toUser,
  validateAccessToken,
  validateAccessTokenOrUndefined
};
//# sourceMappingURL=index.mjs.map